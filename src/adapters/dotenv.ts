/**
 * DotEnv Adapter
 * Parse and generate .env files with proper handling of edge cases
 */

export interface DotEnvParseOptions {
  multiline?: boolean;
  expandVars?: boolean;
  trimValues?: boolean;
}

export interface DotEnvParseResult {
  values: Record<string, string>;
  errors: Array<{ line: number; message: string }>;
}

/**
 * Parse .env file content
 */
export function parseDotEnv(
  content: string,
  options: DotEnvParseOptions = {},
): DotEnvParseResult {
  const {
    multiline = false,
    expandVars = false,
    trimValues = true,
  } = options;

  const values: Record<string, string> = {};
  const errors: Array<{ line: number; message: string }> = [];

  const lines = content.split('\n');
  let currentLine = 0;
  let multilineKey: string | null = null;
  let multilineValue = '';

  for (let i = 0; i < lines.length; i++) {
    currentLine = i + 1;
    let line = lines[i];

    // Handle multiline values
    if (multilineKey) {
      if (line.includes('"') && !line.trim().startsWith('#')) {
        // End of multiline value
        const endIndex = line.indexOf('"');
        multilineValue += '\n' + line.substring(0, endIndex);
        values[multilineKey] = multilineValue;
        multilineKey = null;
        multilineValue = '';
        continue;
      } else {
        multilineValue += '\n' + line;
        continue;
      }
    }

    const trimmed = line.trim();

    // Skip empty lines and comments
    if (!trimmed || trimmed.startsWith('#')) {
      continue;
    }

    // Find equals sign
    const eqIndex = trimmed.indexOf('=');
    if (eqIndex === -1) {
      errors.push({
        line: currentLine,
        message: 'Invalid line: missing = separator',
      });
      continue;
    }

    const key = trimmed.substring(0, eqIndex).trim();
    let value = trimmed.substring(eqIndex + 1);

    // Validate key name
    if (!/^[A-Z_][A-Z0-9_]*$/i.test(key)) {
      errors.push({
        line: currentLine,
        message: `Invalid key name: "${key}" (must start with letter or underscore)`,
      });
      continue;
    }

    // Handle quoted values
    if (value.startsWith('"')) {
      // Check for escaped quotes
      if (value.endsWith('"') && !value.endsWith('\\"')) {
        // Complete quoted value
        value = unescapeValue(value.slice(1, -1));
      } else if (multiline) {
        // Start of multiline value
        multilineKey = key;
        multilineValue = value.slice(1);
        continue;
      }
    } else if (value.startsWith("'")) {
      // Single-quoted values
      if (value.endsWith("'")) {
        value = value.slice(1, -1);
      }
    } else if (trimValues) {
      value = value.trim();
    }

    // Expand variables if requested
    if (expandVars) {
      value = expandEnvVars(value, values, process.env);
    }

    values[key] = value;
  }

  // Check for unclosed multiline value
  if (multilineKey) {
    errors.push({
      line: currentLine,
      message: `Unclosed multiline value for key "${multilineKey}"`,
    });
  }

  return { values, errors };
}

/**
 * Generate .env file content from values
 */
export function generateDotEnv(
  values: Record<string, string>,
  options: { pretty?: boolean; comments?: boolean } = {},
): string {
  const { pretty = true, comments = false } = options;

  const lines: string[] = [];

  // Add header comment
  if (comments) {
    lines.push('# Environment Configuration');
    lines.push('# Generated by TER');
    lines.push('');
  }

  for (const [key, value] of Object.entries(values)) {
    // Decide if value needs quotes
    const needsQuotes = value.includes(' ') ||
      value.includes('\n') ||
      value.includes('\r') ||
      value.includes('#') ||
      value.includes('=');

    let line: string;
    if (needsQuotes) {
      const escaped = escapeValue(value);
      line = `${key}="${escaped}"`;
    } else {
      line = `${key}=${value}`;
    }

    lines.push(line);

    if (pretty) {
      // Could add padding or comments here
    }
  }

  return lines.join('\n');
}

/**
 * Merge multiple .env objects
 */
export function mergeDotEnv(
  ...sources: Array<Record<string, string>>
): Record<string, string> {
  const result: Record<string, string> = {};

  for (const source of sources) {
    Object.assign(result, source);
  }

  return result;
}

/**
 * Get differences between two .env objects
 */
export function diffDotEnv(
  old: Record<string, string>,
  new_values: Record<string, string>,
): {
  added: Record<string, string>;
  removed: string[];
  modified: Record<string, { old: string; new: string }>;
} {
  const added: Record<string, string> = {};
  const removed: string[] = [];
  const modified: Record<string, { old: string; new: string }> = {};

  // Find added and modified
  for (const [key, value] of Object.entries(new_values)) {
    if (!(key in old)) {
      added[key] = value;
    } else if (old[key] !== value) {
      modified[key] = { old: old[key], new: value };
    }
  }

  // Find removed
  for (const key of Object.keys(old)) {
    if (!(key in new_values)) {
      removed.push(key);
    }
  }

  return { added, removed, modified };
}

/**
 * Validate .env content
 */
export function validateDotEnv(content: string): { valid: boolean; errors: string[] } {
  const result = parseDotEnv(content);

  if (result.errors.length === 0) {
    return { valid: true, errors: [] };
  }

  return {
    valid: false,
    errors: result.errors.map((e) => `Line ${e.line}: ${e.message}`),
  };
}

/**
 * Private: Unescape value
 */
function unescapeValue(value: string): string {
  return value
    .replace(/\\n/g, '\n')
    .replace(/\\r/g, '\r')
    .replace(/\\t/g, '\t')
    .replace(/\\"/g, '"')
    .replace(/\\\\/g, '\\');
}

/**
 * Private: Escape value for quoting
 */
function escapeValue(value: string): string {
  return value
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t');
}

/**
 * Private: Expand variables in value
 */
function expandEnvVars(
  value: string,
  localVars: Record<string, string>,
  processEnv: NodeJS.ProcessEnv,
): string {
  return value.replace(/\$\{([^}]+)\}/g, (match, varName) => {
    return localVars[varName] ?? processEnv[varName] ?? match;
  });
}
